使用 res.send 方式响应

```js
const html = fs.readFileSync("./index.html");

const server = http.createServer((req, res) => res.end(html));
```

<img src="笔记.assets/image-20220621173219793.png" alt="image-20220621173219793" style="zoom:50%;" />

使用 createReadStream 方式响应

```js
const html = fs.readFileSync("./index.html");
const server = http.createServer((req, res) => {
  fs.createReadStream("./index.html").pipe(res);
});
```

<img src="笔记.assets/image-20220621173528640.png" alt="image-20220621173528640" style="zoom:50%;" />

如果使用 res.write(chunk) ， res 就会边写入边向浏览器响应，同时进行，此时无法写入响应 headers；

```js
const rs = fs.createReadStream("./index.html");
let arr = [];

rs.on("data", function (chunk) {
    arr.push(chunk); //chunk是buffer类型
    res.write(chunk);
});

//Buffer.concat合并小buffer
rs.on("end", function (chunk) {
    // 此时 res 已经发送出去，无法再写入 header
    const content = Buffer.concat(arr).toString();
    res.setHeader("Content-Length", content.length);
    res.end(); // 最后需要调用 res.end， 否则响应不会终止，页面将一直处于加载中
});

rs.on("error", function (err) {
    console.log(err);
});
```



## 作业01

- 初阶：继续完善静态服务器，使其基于 stream，并能给出正确的 Content-Length。

  ```js
  const rs = fs.createReadStream("./index.html");
  let arr = [];
  rs.on("data", function (chunk) {
      arr.push(chunk); //chunk是buffer类型
  });
  
  //Buffer.concat合并小buffer
  rs.on("end", function (chunk) {
      const content = Buffer.concat(arr).toString();
      res.setHeader("Content-Length", content.length);
      res.end(content);
  });
  ```

  

- 高阶：继续完善静态服务器，使其作为一个命令行工具，支持指定端口号、读取目录、404、stream (甚至 trailingSlash、cleanUrls、rewrite、redirect 等)。可参考 [serve-handler (opens new window)](https://github.com/vercel/serve-handler)。

  > 代码参考 https://github.com/shfshanyue/mini-code/tree/master/code/serve

- 面试：什么是 rewrite 和 redirect

  ##### redirect

  通过重定向，浏览器知道页面位置发生变化，从而改变地址栏显示的地址。

  通过重定向，搜索引擎意识到页面被移动了，从而更新搜索引擎索引，将原来失效的链接从搜索结果中移除。

  临时重定向(R=302)和永久重定向(R=301)都是亲搜索引擎的，是SEO的重要技术。

  redirect是浏览器和服务器发生两次请求，也就是服务器命令客户端“去访问某个页面”；

  redirect的URL需要传送到客户端。

  redirect是从一个地址跳转到另一个地址。

  #### rewrite 

  rewrite的URL只是在服务器端

  rewrite则是服务器内部的一个接管，在服务器内部告诉“某个页面请帮我处理这个用户的请求”，浏览器和服务器只发生一次交互，浏览器不知道是该页面做的响应，浏览器只是向服务器发出一个请求。

  URL重写用于将页面映射到本站另一页面，若重写到另一网络主机（域名），则按重定向处理。

  rewrite是把一个地址重写成另一个地址。地址栏不跳转。相当于给另一个地址加了一个别名一样。



centos 安装 git

```sh
sudo yum install -y git
git --version #查看 git 版本
```

拉取代码

```sh
git clone xxx
```

构建镜像

> 如果有多个 dockerfile 文件，就需要指定构建配置文件， --file 或 -f

```sh
docker build -t simple-app . --file node.Dockerfile  # --file 简写 -f 指定 dockerfile 文件
```

```bash
# 根据该镜像运行容器
# 如果需要在后台运行则添加 -d 选项
# --rm: 当容器停止运行时，自动删除容器
# -p: 3000:3000，将容器中的 3000 端口映射到宿主机的 3000 端口，左侧端口为宿主机端口，右侧为容器端口
$ docker run --rm -p 3000:3000 simple-app

# 运行成功后可在另一个窗口查看所有容器
$ docker ps
CONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS          PORTS                                       NAMES
50784910f758   simple-app   "docker-entrypoint.s…"   20 seconds ago   Up 20 seconds   0.0.0.0:3000->3000/tcp, :::3000->3000/tcp   wizardly_solomon
```

## 作业02

- 初阶: 通过 docker/docker-compose 将单文件 html 进行部署

- 面试: 我们为什么可以直接在 node 镜像中使用 yarn 命令行工具

  ```bash
  我们选择 node:14-alpine (opens new window)作为基础镜像，其中基于轻量操作系统 alpine，内置了 node14/npm/yarn 等运行环境。
  ```

  