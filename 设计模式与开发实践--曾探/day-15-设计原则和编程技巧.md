# 一、原则

## 01、单一职责原则（SRP）

### 一、定义

单一职责原则（SRP）的职责被定义为“引起变化的原因”。

SRP 原则体现为：一个对象（方法）只做一件事情。

如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大；是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。

### 二、何时应该分离职责

SRP 原则是所有原则中最简单也是最难正确运用的原则之一。并不是所有的职责都应该一一分离。

- 一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在 ajax请求的时候，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 对象的职责和发送xhr 请求的职责就没有必要分开。

- 另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。

- 在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。

### 三、SRP 原则的优缺点

#### 优点：

SRP 原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。

#### 缺点

但 SRP 原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。



## 02、最少知识原则

最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。

### 一、减少对象之间的联系

单一职责原则可以把对象划分成较小的粒度，这可以提高对象的可复用性。但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。对象和对象耦合在一起，有可能会降低它们的可复用性。在程序中，对象的“朋友”太多并不是一件好事。

在设计程序时，最少知识原则要求应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。

最少知识原则在设计模式中体现得最多的地方是中介者模式和外观模式；

外观模式的作用是对客户屏蔽一组子系统的复杂性。外观模式对客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现。外观模式的关键是定义一个高层接口去封装一组“子系统”，在JavaScript 中，这个子系统至少应该指的是一组函数的集合。

### 二、封装在最少知识原则中的体现

- 封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口 API 供外界访问。

- 对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内，同时，封装也用来限制变量的作用域。把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小。这也是广义的最少知识原则的一种体现。

### 三、优缺点

遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难以维护的第三者对象。在实际开发中，是否选择让代码符合最少知识原则，要根据具体的环境来定。



## 03、开放-封闭原则

在面向对象的程序设计中，开放封闭原则（OCP）是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放封闭原则的。

定义：

软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。

思想：

当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。

### 用对象的多态性消除条件分支

过多的条件分支语句是造成程序违反开放封闭原则的一个常见原因。每当需要增加一个新的 if 语句时，都要被迫改动原函数。 if 换成 switch-case 是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的 if 或者 swtich-case 语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。

- 找到不变的部分；

  ```js
  var makeSound = function( animal ){ 
   animal.sound(); 
  }; 
  // 各个不同的实体，都有同一个特性方法
  var Duck = function(){}; 
  Duck.prototype.sound = function(){ 
   console.log( '嘎嘎嘎' ); 
  }; 
  var Chicken = function(){}; 
  Chicken.prototype.sound = function(){ 
   console.log( '咯咯咯' ); 
  }; 
  makeSound( new Duck() ); // 嘎嘎嘎
  makeSound( new Chicken() ); // 咯咯咯
  /********* 增加动物狗，不用改动原有的 makeSound 函数 ****************/ 
  var Dog = function(){}; 
  Dog.prototype.sound = function(){ 
   console.log( '汪汪汪' ); 
  }; 
  makeSound( new Dog() );
  ```

- 找出变化的部分，将变化封装起来；通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需要改变的。

### 其他方法

除了利用对象的多态性之外，还有其他方式可以帮助我们编写遵守开放/封闭原则的代码；

#### 1、 放置挂钩

放置挂钩（hook）也是分离变化的一种方式。我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。

由于子类的数量是无限制的，总会有一些“个性化”的子类迫使我们不得不去改变已经封装好的算法骨架。于是我们可以在父类中的某个容易变化的地方放置挂钩，挂钩的返回结果由具体子类决定。这样一来，程序就拥有了变化的可能。

#### 2、使用回调函数

函数可以作为参数传递给另外一个函数，这是高阶函数的意义之一。在这种情况下，我们通常会把这个函数称为回调函数。在 JavaScript 版本的设计模式中，策略模式和命令模式等都可以用回调函数轻松实现。

回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。

### 设计模式中的开放-封闭原则

几乎所有的设计模式都是遵守开放封闭原则的，我们见到的好设计，通常都经得起开放封闭原则的考验。不管是具体的各种设计模式，还是更抽象的面向对象设计原则，比如单一职责原则、最少知识原则、依赖倒置原则等，都是为了让程序遵守开放封闭原则而出现的。可以这样说，开放封闭原则是编写一个好程序的目标，其他设计原则都是达到这个目标的过程。

#### 1、发布订阅模式

发布订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。

#### 2、模板方法模式

模板方法模式是一种典型的通过封装变化来提高系统扩展性的设计模式。在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放封闭原则的。 

#### 3、 策略模式

策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。增加一个新的策略类也非常方便，完全不用修改之前的代码。

#### 4、代理模式

提供一个代理函数 ，代理函数负责额外的附加功能，再将请求转交给原来的 主体函数，主体函数在这个过程中不需要任何改动。附加功能和主体功能被隔离在两个函数里，它们可以单独改变而互不影响。主体函数不知晓代理的存在，它可以继续专注于自己的职责。

#### 5、职责链模式

请求在一个链条中传递，直到命中目标，就会在命中的节点中执行；只需要维护好各个节点之间的顺序即可；不足是会加长代码运行流程。



让程序符合开放封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增大代码的复杂度。更何况，有一些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化。可以做到的有下面两点。

- 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。

- 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单。 

# 二、代码重构

#### 1、提炼函数

如果一个函数过长，不得不加上若干注释才能让这个函数显得易读一些，那这些函数就很有必要进行重构。如果在函数中有一段代码可以被独立出来，那我们最好把这些代码放进另外一个独立的函数中。这是一种很常见的优化工作，这样做的好处主要有以下几点。

- 避免出现超大函数。

- 独立出来的函数有助于代码复用。

- 独立出来的函数更容易被覆写。

- 独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用

#### 2、合并重复的条件片段

对一些重复的分支语句或其他重复语句，进行合并处理；

#### 3、把条件分支语句提炼成函数

```js
var getPrice = function( price ){ 
    var date = new Date(); 
    if ( date.getMonth() >= 6 && date.getMonth() <= 9 ){ // 夏天
        return price * 0.8; 
    } 
    return price; 
}; 
// 重构后
var isSummer = function(){ 
    var date = new Date(); 
    return date.getMonth() >= 6 && date.getMonth() <= 9; 
}; 
var getPrice = function( price ){ 
    if ( isSummer() ){ // 夏天
        return price * 0.8; 
    } 
    return price; 
};
```



#### 4、合理使用循环

```js
var createXHR = function(){ 
    var xhr; 
    try{ 
        xhr = new ActiveXObject( 'MSXML2.XMLHttp.6.0' ); 
    }catch(e){ 
        try{ 
            xhr = new ActiveXObject( 'MSXML2.XMLHttp.3.0' ); 
        }catch(e){ 
            xhr = new ActiveXObject( 'MSXML2.XMLHttp' ); 
        } 
    } 
    return xhr; 
}; 
var xhr = createXHR();

// 改造后如下：
var createXHR = function(){ 
    var versions= [ 'MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp' ]; 
    for ( var i = 0, version; version = versions[ i++ ]; ){ 
        try{ 
            return new ActiveXObject( version ); 
        }catch(e){ 
        } 
    } 
}; 
var xhr = createXHR();
```



#### 5、提前让函数退出代替嵌套条件分支

#### 6、传递对象参数代替过长的参数列表

#### 7、尽量减少参数数量

#### 8、少用三目运算符

- 相比损失的代码可读性和可维护性，三目运算符节省的代码量也可以忽略不计；
- 如果条件分支逻辑非常复杂，那最好的选择还是按部就班地编写if、else。if、else 语句的好处很多，一是阅读相对容易，二是修改调试的时候比修改三目运算符周围的代码更加方便；

#### 9、合理使用链式调用

- 链式调用带来的坏处就是在调试的时候非常不方便，如果一条链中有错误出现，必须得先把这条链拆开才能加上一些调试 log 或者增加断点，这样才能定位错误出现的地方。如果该链条的结构相对稳定，后期不易发生修改，那么使用链式调用无可厚非。

- 如果该链条很容易发生变化，导致调试和维护困难，那么还是建议使用普通调用的形式；

#### 10、分解大型类

面向对象设计鼓励将行为分布在合理数量的更小对象之中

#### 11、用 return 退出多重循环

如果在return 后还有需要执行的代码，就将这些代码放到 return 后面，如果代码比较多，就应该把它们提炼成一个单独的函数；

```js
var print = function( i ){ 
    console.log( i ); 
}; 
var func = function(){ 
    for ( var i = 0; i < 10; i++ ){ 
        for ( var j = 0; j < 10; j++ ){ 
            if ( i * j >30 ){ 
                return print( i ); 
            } 
        } 
    } 
}; 
func();
```























